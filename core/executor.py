"""
The Executor module for the agentic RAG pipeline.

This module is responsible for executing the action plan generated by the Planner.
It iterates through each step of the plan, calls the appropriate tool or retriever,
and stores the results.
"""
from typing import Dict, Any, List
from ..utils.schema import ActionPlan, DocumentChunk
from ..utils.logging import get_logger

logger = get_logger(__name__)

class Executor:
    """
    Executes an action plan step by step.
    """
    def __init__(self, tools: Dict[str, Any]):
        """
        Initializes the Executor.

        Args:
            tools (Dict[str, Any]): A dictionary mapping tool names to their
                                   instantiated objects (e.g., {"hybrid_retriever": HybridRetriever()}).
        """
        self.tools = tools
        logger.info(f"Executor initialized with tools: {list(tools.keys())}")

    def execute_plan(self, plan: ActionPlan) -> Dict[int, Any]:
        """
        Executes the entire action plan and returns the results of each step.

        Args:
            plan (ActionPlan): The action plan to execute.

        Returns:
            Dict[int, Any]: A dictionary mapping each step ID to its output.
        """
        logger.info(f"Starting execution of plan for query: '{plan.query}'")
        step_results = {}

        for step in plan.plan:
            logger.info(f"Executing step {step.id}: {step.action} with tool {step.tool}")

            # TODO: Implement dependency injection for step inputs.
            # A step might need the output of a previous step.
            # E.g., input: {"query": "population of {step_1_output}"}
            # This requires parsing the input dict for references to previous steps.
            # For now, we assume inputs are self-contained.

            tool_to_call = self.tools.get(step.tool)
            if not tool_to_call:
                logger.error(f"Tool '{step.tool}' not found in available tools.")
                step_results[step.id] = {"error": f"Tool '{step.tool}' not found."}
                continue

            try:
                # Assuming each tool has an `execute` method.
                # This is a convention we need to enforce for all tools.
                if hasattr(tool_to_call, 'execute'):
                    output = tool_to_call.execute(**step.input)
                elif hasattr(tool_to_call, 'retrieve'): # For retrievers
                    output = tool_to_call.retrieve(**step.input)
                else:
                    raise AttributeError(f"Tool {step.tool} does not have an 'execute' or 'retrieve' method.")

                # TODO: Add output validation against `step.expected_output_schema`.
                # This could involve type checking or even using Pydantic models.

                step_results[step.id] = output
                logger.debug(f"Step {step.id} output: {output}")

            except Exception as e:
                error_message = f"Error executing step {step.id} with tool {step.tool}: {e}"
                logger.error(error_message)
                step_results[step.id] = {"error": error_message}

        logger.info("Finished executing plan.")
        return step_results

# Example usage:
# if __name__ == '__main__':
#     from ..utils.schema import ActionStep
#
#     class MockTool:
#         def execute(self, query):
#             return f"Result for '{query}'"
#
#     tools = {"web_search": MockTool()}
#     executor = Executor(tools=tools)
#
#     plan = ActionPlan(
#         query="What is the capital of France?",
#         reasoning="N/A",
#         plan=[
#             ActionStep(id=1, action="find_capital", tool="web_search", input={"query": "capital of France"}, expected_output_schema="string")
#         ]
#     )
#
#     results = executor.execute_plan(plan)
#     print(results)
